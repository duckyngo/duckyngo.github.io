{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx",
    "path": "/flutter-load-data-before-building-a-widget",
    "result": {"data":{"post":{"slug":"/flutter-load-data-before-building-a-widget","title":"Flutter load data before building a Widget","date":"22.04.2022","tags":[{"name":"Android","slug":"android"},{"name":"Mobile","slug":"mobile"},{"name":"Flutter","slug":"flutter"},{"name":"Firebase","slug":"firebase"}],"description":null,"canonicalUrl":null,"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"slug\": \"flutter-load-data-before-building-a-widget\",\n  \"title\": \"Flutter load data before building a Widget\",\n  \"date\": \"2022-04-22T00:00:00.000Z\",\n  \"tags\": [\"Android\", \"Mobile\", \"Flutter\", \"Firebase\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Sometimes while making a new screen, we need to have the data first and then show it on the widget. It can be getting data from the Internet, reading data from Firebase, or loading from a file. Here are some ways to help us prepare the data before showing it on the widget\"), mdx(\"h3\", null, \"1. Using \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"FutureBuilder \"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"FutureBuilder<VOAAudio?>(\\n    future: FirestoreProvider.getFirestoreAudioObject(ObjectId), // Load your data here\\n    builder: (context, snapshot) {\\n      if (snapshot.hasData) {\\n        _pageManager.init(snapshot.data!.audio!);\\n        return SafeArea(\\n            child: Column(children: <Widget>[\\n          Expanded(\\n            child: Stack(\\n              children: [...]\\n        } else if (snapshot.hasError) {\\n        return Text('${snapshot.error}');\\n      }\\n      // By default, show a loading spinner.\\n        return new Center(child: const CircularProgressIndicator());\\n\")), mdx(\"p\", null, \"With this solution, our application gets new data whenever the Widget gets updated by calling the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"build\"), \" function. Sometimes, It can be a problem. We can just load the data once in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"initState()\"), \" function by the next solution\"), mdx(\"h3\", null, \"2. Using \", mdx(\"em\", {\n    parentName: \"h3\"\n  }, \"async\"), \" function and \", mdx(\"em\", {\n    parentName: \"h3\"\n  }, \"then\"), \"  inside \", mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"initState()\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"// First define your async loading function\\nFuture<VOAAudio?> loadFirestoreAudioObject() async {\\n  VOAAudio? voaAudio = await FirestoreProvider.getFirestoreAudioObject(ObjectId);\\n  return voaAudio;\\n}\\n\\n// Then call the async function in initState with then\\n@override\\nvoid initState() {\\n  super.initState();\\n  _pageManager = PageManager();\\n  loadFirestoreAudioObject().then((value) {\\n    voaLoaded = true;\\n    if(value != null) {\\n      _voaAudio = value;\\n    } else {\\n      voaLoadingError = false;\\n    }\\n    setState(() {});\\n  });\\n}\\n\\n@override\\nWidget build(BuildContext context) {\\nreturn MaterialApp(\\n    home: Scaffold(\\n    body: LayoutBuilder(builder: (context, constraints) {\\n\\n        // Update your View after loading data\\n        if(voaLoadingError){\\n            return const Text(\\u201CConnection error!\\u201D);\\n        } else if(voaLoading){\\n            return SafeArea(\\u2026)\\n        }\\n\\n        // By default, show a loading spinner.\\n        return const Center(child: CircularProgressIndicator());\\n    }),)\\n);\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Sometimes while making a new screen, we need to have the data first and then show it on the widget. It can be getting data from the Internetâ€¦","timeToRead":1,"banner":null}},"pageContext":{"slug":"/flutter-load-data-before-building-a-widget","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}